2007-07-23 Taura
	* ioman/ioman.py (ioman.reset_ready_channels_aux):
	When internal write buffer goes beyond a threshold (10KB by default), 
	it used to wait for some write channels to become writable, ignoring
	read channels, in trying to evacuate pending writes first. 
	It caused deadlocks (explore freezes). After this change, it first
	does so with timeout = 0.1, and if no channels become writable, it
	does select again including read channels.

	This hopefully fixes explore freeze bugs experienced by several
	folks.

2007-09-28 Taura
	* gxpd.py (gxpd.handle_INPUT_gxp_stdout_in_progress): When a
	connection (socket) being issued to directly connect parent gxpd
	and the child gxpd (conneted only via underlying rsh-like process)
	gets an exception, the parent used to mis-conclude that the
	connection to the child was entirely lost and the explore failed.
	This used to happen because it does not reason which of the two
	channels (new socket being connected and the old connection via
	rsh-like) got the exception and I used to presume it is the
	latter.  This bug has not revealed because in my environments, the
	connection only succeeds or simply timeout. It revealed when the
	connection to imade starts raising "Connection Refused" exception.
	I don't know why it starts happening, but a bug is a bug.

2007-10-25 Taura
	* gxpd.py (child_process.run): Call os.setpgrp() in the child process.

	* gxpd.py (gxpd.do_action_sig): Upon receiving action_sig msg, it
	now kills the process group, not a single process. This change and
	the above changed the semantics of Ctrl-C. Before, only the direct
	child process of gxpd, which ic actually /bin/sh, receives SIGINT.
	Now /bin/sh and all its descendants do.

	
	* gxpbin/gxp_mom (main): Changed the way the mom
	terminates. Before, it did not correctly terminate.
	see comments in gxp_mom just above main.

2007-10-26 Taura
	* inst_local.py (many places):
	* gxpc (cmd_interpreter.mk_explore_cmd): Changed they way in which
	information necessary for remote installation is passed between
	gxpc and inst_local.py. Previously gxpc explictly supplies everything
	and inst_local.py has no builtin knowledge. It resulted in very long
	command line arguments awkwardly shown in ps output. Now only 
	information that changes from an invocation to another is expclitly
	given. Other options have builtin default values in inst_local.py and
	can be overwritten as before (by explicitly giving options).

2007-10-26 Taura
	* inst_local.py (installer.remote_installed): Changed the way
	automatic installation (on explore) works. The new version avoids
	a version incosisency problem that happens when gxp is installed
	in the same path on the remote host, but their versions are
	incosistent.  Previously, explore first tries to bring up gxpd,
	hoping that there is gxpd in the same path as the local host. When
	this succeeds, explore is fast. An important case is when nodes in
	a cluster share a home directory and gxp is installed under
	somewhere below the home. If, however, local and remote hosts
	happen to have gxp in a local (not shared) directory, versions may
	be inconsistent. The new version takes the fast path only when the
	local gxp was automatically installed. Since the automatic
	installation is done under a randomly generated path, so if the
	path names of two such directories match, it is likely that they
	are really identical (shared) directories.
	
2007-11-27 Taura
	* ioman.py (child_process.discard): Fixed a bug that gxpc trim leaves
	some child gxpd (more precisely, inst_local.py). trim calls discard
	method on child_peer class, which used to call discard methods on all
	its read channels. Now it calls discard methods on all write channels too.
	I don't know why I did it in the first place. I hope this happened by
	chance and this fix does not have any side effect.

2007-12-2 Taura
	* gxpd.py (gxpd.cleanup_process): Fixed a descriptor-leak bug that
	does not close write-pipe connected to a child process (e.g., pipe
	connected to stdin of child process). This fixes a problem that
	gxpd dies after invoking child processes thousands times.

2007-12-25 Taura
        * gxpd.py (gxpd.upgrade_parent_peer):
        * gxpd.py (gxpd.cleanup_process):
        * gxpd.py (gxpd.handle_OUTPUT_gxp):
	* gxpd.py (gxpd.handle_INPUT_gxp_live): Fixed a bug in which gxp
	freezes when a connection is reset by a router. This used to
	happen in the following scenario (e.g., between hongo-charlie and
	kyoto-charlie).
	(a) host A explores host B.
	(b) there is no action for a long time (e.g., 10,000 sec)
	(c) gxpc ping (it freezes)

	What was happening is this.
	(1) Host A explores host B (e.g., via ssh).
	(2) After establishing ssh connection to B, host A tries to
	directly connect to B and it succeeds. From now on, host A uses
	the new connection to talk to B.  The original connection (ssh)
	still remains.
	(3) After a long period (e.g., 10,000 sec) of no interaction
	between A and B, the new connection is reset by a router (that
	this happens was verified by a simple separate program using a
	socket). Neither A nor B notices the event until it tries to
	communication the next time. The ssh connection does not seem to
	be reset (it keeps the connection alive?).
	(4) The next time A tries to talk to B (e.g., via gxpc ping), it
	still thinks B is alive, sends a ping msg, and expects a reply to
	come.
	(5) While waiting for the reply, A notices that the connection to
	B is reset, but since the other (ssh) connection is still alive, A
	does NOT consider B is dead and keeps waiting for the reply, which
	will never come (the ssh connectin is NEVER used any more).
	
	This bug has been fixed in the following ways.
	(1) When a connection to a child GXP is broken by receiving
	IO_ERROR (handle_INPUT_gxp_live or handle_OUTPUT), the parent
	unconditionally considers the child is dead (calls proc.discard).
	(2) When proc.discard is called and some tasks are using the
	process, an error message will appear saying ("gxp process YYY is
	dead").

	After this bug is fixed, the expected behavior in the above
	scenario is at step (c), you get the error message "gxp process YYY
	is dead" instead of freezing.

2008-1-2 Taura
	Added "timeout" global_option. If explore, e-like, or ping does
	not terminated within the specified timeout, gxpc simply quits.
	The action might still be ongoing on the gxpd side, so this should
	be used as a last resort.
	
2008-1-2 Taura
	Changed the directory in which sockets and session states are
	saved.  Previously, they are created under /tmp/gxp-<user>/ but
	now in /tmp/gxp-<user>-default/ . If environment variable
	GXP_TMP_SUFFIX is set, they are saved under
	/tmp/gxp-<user>-$GXP_TMP_SUFFIX/.  This allows us not to confuse
	interactive GXP sessions by having multiple sessions in the
	/tmp/gxp-<user>-default/ directory.

2008-2-17 Taura
        * gxpbin/mount_all:
	Fixed a bug that mount_all does not terminate. It was because,
	when sshfs is execed with file descriptors 3 and 4 open, they get
	duplicated and hence will not be close even after mount_all itself
	exited.
2008-3-20 Taura
	* ioman.py:child_process.kill It now uses KILL signal to kill the
	process. The problem occurs when ssh (invoked by explore) asks
	password. When explore is run from the same terminal as gxpd, ssh
	enters infinite loop. When explore is run from a different
	terminal as gxpd, ssh seems to enter "STOPPED" mode (indicated as
	'T' by ps command). Either case, inst_local.py appears to fail to
	kill that process (I don't understand why it fails in the former
	case). 
	
2008-7-8 Taura
	* su_cmd: now it does not echo command line and password prompts.

2008-7-9 Taura	
	* gxpd.py: better session interface.
	* gxpc.py: better session interface. A standardized procedure for
	manipulating multiple sessions.
  	export GXP_SESSION=`gxpc --create_daemon 1`
	do whatever
	gxpc quit
	existing session won't be affected, including the one created 
	without --create_daemon
	
2008-7-9 Taura
	* gxpc.py: a more intuitive semantics for -h and -H. it now matches
	against hostname, not gupid.

