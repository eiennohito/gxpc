#!/usr/bin/env python
import errno,os,re,sys,socket,string

def Es(s):
    sys.stderr.write(s)

envs_to_pass = [ "MAKEFLAGS", "MAKELEVEL", "MAKEFILES",
                 "GXP_MAKE_SO_NAME" ]

def submit(so_name, cmd):
    cwd = translate_cwd()
    msgs = []
    msgs.append("%9d %s" % (len(cmd), cmd))
    msgs.append("%9d %s" % (len(cwd), cwd))
    for var in envs_to_pass:
        if os.environ.has_key(var):
            varval = "%s=%s" % (var, os.environ[var])
            msgs.append("%9d %s" % (len(varval), varval))
    so = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        so.connect(so_name)
    except socket.error,e:
        if e.args[0] == errno.ECONNREFUSED:
            # Es("mksh: could not connect to job scheduler %s\n" % (e.args,))
            sys.exit(125)
        else:
            raise
    so.send(string.join(msgs, ""))
    so.shutdown(1)
    fd = so.fileno()
    os.dup2(fd, 0)
    os.execvp("sh",
              [ "sh", "-c", "if read x; then exit $x; else exit 126; fi" ])

local_pat = re.compile("(===+)")
def submit_or_exec(so_name, cmd):
    """
    judge whether we should exec the command by this process or
    pass it to xmake.
    an important requirement is we need to exec directly if the
    command is invoked by $(shell ...), because make expects its
    stdout. if we pass it to xmake, this process does not print
    what the cmd does.

    here is the tricky way to judge if a command is run by shell.
    it appears that
    (1) $(shell ...) is run by the toplevel make, there are no MAKEFLAGS
    rule:
    no MAKEFLAGS -> must not tsubmit
    
    
    """
    # Es("envenv=%s\n" % os.environ)
    local_exec_cmd = os.environ.get("GXP_MAKE_LOCAL_EXEC_CMD", "")
    m = local_pat.match(cmd)
    if m and len(m.group(1)) >= 3:
        n_equals = m.end(1)
        # if it begins with === or more equals, do not submit
        # Es("local by %s\n" % m.group(1))
        os.execvp("sh", [ "sh", "-c", string.lstrip(cmd[n_equals:]) ])
    elif local_exec_cmd != "" and re.match(local_exec_cmd, cmd):
        os.execvp("sh", [ "sh", "-c", cmd ])
    elif cmd[0:4] == "make":
        # if this is a recursive make or $(shell ...) thing, do not submit
        # Es("local by recursive make\n")
        lev = string.atoi(os.environ["GXP_MAKELEVEL"])
        os.environ["GXP_MAKELEVEL"] = ("%d" % (lev + 1))
        os.execvp("sh", [ "sh", "-c", cmd ])
    elif string.atoi(os.environ.get("MAKELEVEL", "0")) < string.atoi(os.environ["GXP_MAKELEVEL"]):
        # submit all others
        # Es("local by no MAKEFLAGS\n")
        os.execvp("sh", [ "sh", "-c", cmd ])
    else:
        # os.environ.has_key("MAKEFLAGS") and "w" not in os.environ["MAKEFLAGS"]
        # a tricky way to judge if a command is run by shell.
        # os.environ.has_key("MAKEFLAGS")
        # Es("submit\n")
        submit(so_name, cmd)

def translate_cwd():
    cwd = os.path.normpath(os.getcwd())
    for var,trans in [ ("HOME", "~") ]:
        prefix = os.environ.get(var)
        if prefix is None: continue
        prefix = os.path.normpath(prefix)
        n = len(prefix)
        if cwd == prefix:
            cwd = trans
            continue
        elif len(cwd) > n and cwd[:n] == prefix and cwd[n] == os.path.sep:
            cwd = trans + cwd[n:]
            continue
    return cwd

def main():
    if len(sys.argv) != 3:
        Es("mksh: usage: mksh -c 'CMD'\n")
        sys.exit(1)
    cmd = sys.argv[2]
    so_name = os.environ.get("GXP_MAKE_SO_NAME")
    if so_name is None:
        Es(("mksh: environment var GXP_MAKE_SO_NAME not "
            "defined (perhaps you ran make, not gxpc make?)\n"))
        sys.exit(1)
    submit_or_exec(so_name, cmd)

if __name__ == "__main__":
    main()

