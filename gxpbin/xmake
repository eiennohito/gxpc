#!/usr/bin/env python
import errno,os,sys,random,re,select,shlex,signal,socket,stat,string,time
import cStringIO

import opt
    

"""
Quick example:

Makefile is totally usual:

---------------------------------------
all : 1.dat 2.dat 3.dat 4.dat 5.dat
%.dat : %.src
	your_program $< > $@
---------------------------------------

explore hosts and get ready.

[10/10/10]% gxpc make -k -j 5 
"""

"""
xmake usage:

  (1) grab resources by exploring and smasking as you like.

  (2) run

      gxpc make

  instead of make. this calls unmodified GNU make.
  
  You probably want to give -j N option so that things are run in
  parallel.  It is always good idea not to set N larger than the
  number of workers (hosts you explored).

  You probably also want to give -k option, so that a single failure
  won't stop everything (non-dependent jobs keep running).

  For example, with

      gxpc make -k -j 5

  for the above Makefile, five processes

      your_program {1-5}.src > {1-5}.dat

  will be invoked in parallel.

"""

"""
how it works.

---- : process parent/child relationship
.... : connections (UNIX domain socket)

gxpc make
  |
xmake --------------- gxpc ...
  |                          .
  |                          .
  |                          .    
GNU make ---- mksh           .    
         ---- mksh           .       <distributed processes>
         ---- mksh           .    
         ---- mksh          gxpd --- gxpd --- ... (resources)
            ...                       +-------gxpd --- ... 
         ---- mksh                    +-------gxpd --- ... 
         ---- mksh                             +-------gxpd --- ... 
         ---- mksh
                         
Also, there is a connection between each mksh to xmake (not indicated
in the figure).

This process (xmake) will simply run GNU make passing through whatever
command lines to it. GNU make will run subprocesses VIA THE SPECIFIED
MKSH. Before launching GNU make, it will run a master process with gxp
by

   gxpc e --persist 1 --tid hogehoge

This command line ensures the task hogehoge persists even if no
processes are running.

Meanwhile, GNU make invokes mksh like a regular shell, i.e., mksh -c
COMMAND.  It connects to this (xmake) process and requests the command
line to be dispatched.

xmake enques received command lines, selects a free worker for each,
and once a worker is found, dispatches it with the following command.

    gxpc e --tid hogehoge --keep_connection 0 <command>

This command line will add a process to the existing task 'hogehoge'
(created in the beginning) and immediately closes the connection
between gxpc and gxp daemon. The net effect is the gxpc just invoked
immediately terminates (thus release the memory resource).  The output
is sent to the master process and the termination detected by the
master process. When a command is terminated, xmake notifies the
original requester (one of those mksh's) of it by sending the message
to the connection and closing it.

For handling large number of jobs, it is critical to represent
outstanding (issued by GNU make but not finished) jobs as compactly as
possible. To this end, gxpc for individual command lines immediately
terminate as indicated above.  In addition, the waiting mksh will
'become' (exec) a small shell command line whose only job is to
receive the termination message (specifically, "if read x; then exit
$x; else exit 126; fi"). Memory footprint for such a shell process
seems 200KB - 300KB.

"""


dbg=0

def Es(s):
    sys.stderr.write(s)
    sys.stderr.flush()

def Ws(s):
    sys.stdout.write(s)
    sys.stdout.flush()

class xmake_cmd_opts(opt.cmd_opts):
    def __init__(self):
        #             (type, default)
        # types supported
        #   s : string
        #   i : int
        #   f : float
        #   l : list of strings
        #   None : flag
	opt.cmd_opts.__init__(self)
        # log file
        self.log      = ("s", "xmake.log")
        # state file directory
        self.state_dir = ("s", "./")
        # state file 
        self.state    = ("s", "state.html")
        # parallelism file
        self.parallelism_gpl = ("s", "parallelism.gpl")
        self.parallelism_terminal = ("s", "png") # gnuplot type
        self.parallelism_image = ("s", "parallelism.png")
        self.gnuplot_err = ("s", "gnuplot.err")
        self.max_records = ("i", 10000)
        self.max_records_in_page = ("i", 500)
        self.local_exec_cmd = ("s", None) 
        #
        self.conf = ("s", "~/gxpc_make.conf")
        #
        self.update_interval_1 = ("f", 2.0)
        self.update_interval_2 = ("f", 20.0)
        self.auto_update_interval = ("i", 60.0)
        self.time_limit = ("s", None)
        self.no_dispatch_after = ("i", None)
        self.interrupt_at = ("i", None)
        self.exit_status_worker_dead = ("i", 123)
        self.exit_status_time_limit = ("i", 124)
        self.exit_status_connect_failed = ("i", 125)
        self.exit_status_server_dead = ("i", 126)
        
        # in case you want to run GNU make with a different name
        self.make     = ("s", "make")
        self.stage_in = ("s", None)     # "./stage_in"
        self.gxpc     = ("s", "gxpc")
        self.qlen     = ("i", 10000)
        self.sem      = ("s*", [])
        self.emulate  = (None, 0)
        self.help     = (None, 0)
        self.h        = "help"
        self.n        = "emulate"

    def postcheck(self):
        # self.time_limit is like "a:b", it is treated as if
        # --no_dispatch_after a and --interrupt_at b are given
        if self.time_limit is not None:
            # parse time_limit (like 30:60) and set
            # no_dispatch_after = 30 and interrupt_at = 60
            limits = string.split(self.time_limit, ":", 1)
            if len(limits) == 1:
                [ no_dispatch_after_s ] = limits
                interrupt_at_s = ""
            else:
                [ no_dispatch_after_s, interrupt_at_s ] = limits
            if no_dispatch_after_s == "":
                no_dispatch_after = None # omitted. infty
            else:
                no_dispatch_after = self.safe_atof(no_dispatch_after_s, -1)
                if no_dispatch_after == -1:
                    Es("xmake: invalid time limit (%s)\n" % self.time_limit)
                    return -1
            if interrupt_at_s == "":
                interrupt_at = None
            else:
                interrupt_at = self.safe_atof(interrupt_at_s, -1)
                if interrupt_at == -1:
                    Es("xmake: invalid time limit (%s)\n" % self.time_limit)
                    return -1
            # now we have no_dispatch_after and interrupt_at (floats)
            if self.no_dispatch_after is None:
                self.no_dispatch_after = no_dispatch_after
            if self.interrupt_at is None:
                self.interrupt_at = interrupt_at
        
    def usage(self):
        u = r"""usage:
    gxpc make <GNU make options> [ -- <gxpc make options> ]

GNU make options are whatever options GNU make supports.
gxpc make options:

  --emulate / -n :
      pretend all commands finished successfully. useful to generate
      and see state html file.
  --sem SEM_SPECS :
      specify concurrency constraints for various jobs.
      see SEM_SPECS below.
  --state_dir DIR :
      specify directory where state.html and assocated files are written
      (including xmake.log). created if not exist.
  --state FILE :
      write job/worker status to FILE (default: "state.html")
  --log FILE :
      write log to FILE (default: "xmake.log")
  --update_interval_1 T1 :
      specify the inteval at which status file is updated in seconds
      (default 10.0).
  --update_interval_2 T2 :
      specify the inteval at which status file is updated in seconds
      (default 20.0). more precisely, status file gets updated either when
      (1) T1 seconds has passed since the last update and there are at
      least 10 state changes not reflected in the file, or
      (2) T2 seconds has passed since the last update and there is at
      least 1 state change not reflected in the file.
  --auto_update_interval T :
      specify the interval at which status file is automatically
      reloaded by the browser (<meta http-equiv="refresh" content=T>
      gets inserted in the status file).
  --make GNU_MAKE_PATH :
      specify the path of GNU make (default : "make")
  --gxpc GXPC_PATH :
      specify the path of gxpc (default : "gxpc")
  --qlen N : 
      specify the backlog of the socket the scheduler listens
      (default : 10000). you might want to increase this value
      when there are more than 10000 workers.
  --time_limit soft[:hard]
      soft specifies the time when make stops dispatching jobs. after this time,
      it only waits for outstanding workss to finish, and then throws away all
      jobs (not dispatched) with exit status 124, or what you specify with --exit_status_time_limit. hard specifies the time when
      make kills (with SIGINT) works in progress.
  --exit_status_worker_dead S
      specifies the exit status, perceived by GNU make, for jobs that
      are not completed because the worker is dead. default is 123.
  --exit_status_time_limit S
      specifies the exit status, perceived by GNU make, for jobs that
      are not executed because time_limit (specified by --time_limit option)
      reached. default is 124.
  --exit_status_connect_failed S
      specifies the exit status, perceived by GNU make, for jobs that
      failed to executed because it somehow could not connect to xmake
      (it should not normally happen). default is 125.
  --exit_status_server_dead S
      specifies the exit status, perceived by GNU make, for jobs that
      failed to complete because xmake somehow died (it should not
      normally happen). default is 126.

SEM_SPECS:
  SEM_SPECS ::= SEM_SPEC[,SEM_SPEC]*
  SEM_SPEC  ::= id | id:num
  id is an arbtrary name (without spaces). num is an integer.
  when num is omitted, 1 is assumed.

  id:num says at most num jobs using id can be running at a time.
  you specify which jobs use which resources by writing
  =(id,id,...,id) before the command line in the Makefile.

See http://www.logos.t.u-tokyo.ac.jp/gxp/index.php?gxpc_make for
details of CONCURRENCY CONTROL.
"""
        return u

class Man:
    """
    a worker, or a man
    """
    def __init__(self, name, idx, capacity, t):
        self.name = name                # name
        self.idx = idx                  # serial number
        self.capacity = capacity
        self.time = t                   # created
        self.live = 1                   # initially considered live
        self.last_heartbeat_time = t    # last time at which I heard from him
        self.running = []               # runs this man is working on
        self.runs = []                  # runs this man has worked on

    def set_heartbeat(self, t):
        self.last_heartbeat_time = t

class shot_id_counter:
    def __init__(self):
        self.c = 0
    def get(self):
        c = self.c
        self.c = c + 1
        return "x%d" % c

# terminology
#
# a shot, a run, and a job.
#
# - A job consists of one or more runs (usually a run).
# - A run consists of one or more shots (usually one).
#
# A job is whatever is invoked by a GNU make. That is, a single
# command in your Makefile corresponds to a job.
# 
# A job is dispatched to a node and this event make a single run.
# A job is usually finished by a single run, but if a run fails for
# some reason, there may be more than two runs for a single job.
#
# A run in general consists of one or more shots. For a run that
# just executes a command, there is only one shot for a run.
# If a run needs stage-in / stage-out, a run may consist of 
# shots for stage-in, a shot for the real command, and shots for 
# stage-out.
#
# a job +--+--- first run ----+ shot (stage in)
#          |                  + shot (stage in)
#          |                  + shot (real command)
#          |                  + shot (stage out)
#          |
#          |
#          +--- second run
#          |
#          .
#          .
#
# Put differently from bottom up manner, a shot is whatever is 
# dispatched to a remote node with a single stroke. A series of
# shots to a single worker comprises a run. A single or multiple
# runs will complete a job.
#

class Shot:
    """
    see above explanation also.
    a shot is the smallest unit of work submitted to a worker.
    it may be a stage in command, stage out command, or the real command.

    this is the common ancestor of all shot classes.
    """
    counter = shot_id_counter()
    def __init__(self, server, run, resources):
        self.server = server            # xmake_server object
        self.run = run                  # parent run object this shot is for
        self.resources = resources      # resources (semaphores) needed
        self.time_start = None
        self.time_end = None

    def __str__(self):
        return ("%s(%s with %s)"
                % (self.__class__.__name__, self.cmd, self.resources))

    def shot(self, cur_time):
        """
        'fire' this shot
        """
        self.start_time = cur_time
        if self.run.time_start is None:
            self.run.time_start = cur_time

    def finish(self, status, cur_time):
        """
        called when this shot has finished with status at cur_time
        """
        self.time_end = cur_time
        run = self.run
        assert run.shots[0] is self, (self, run.shots)
        run.shots.pop(0)
        if len(run.shots) == 0 or \
                not os.WIFEXITED(status) or os.WEXITSTATUS(status) != 0:
            # the entire run has finished
            run.finish(status, cur_time)
        else:
            # schedule the next shot in this run
            self.server.shots_todo.append(run.shots[0])

class shot_stage(Shot):
    def setup_redirect(self):
        pass

    def shot(self, cur_time, emulate):
        Shot.shot(self, cur_time)
        if emulate:
            # emulation mode. pretend as if it succeeds
            cmd = "exit 0"
        else:
            cmd = self.cmd
        self.start_time = cur_time
        # build gxpc command line
        cmdx = [self.server.opts.gxpc, "--save_session", "0",
                "e", "-g", self.run.man.name, 
                "--dir", self.run.work.cwd ]
        for var_val in self.run.work.envs:
            cmdx.append("--export")
            cmdx.append(var_val)
        cmdx.append(cmd)
        if self.server.logfp:
            self.server.LOG(("dispatching job to %s (%s)\n"
                             % (self.run.man.name, cmdx)))
        # really run process
        pid = os.fork()
        if pid == 0:
            self.server.close_fds()
            r = self.setup_redirect()
            if r == 1: os._exit(0)       # nothing to do
            if r == -1: os._exit(1)      # error
            os.execvp(cmdx[0], cmdx)
        self.id = pid
        if self.server.logfp:
            self.server.LOG(("child process pid = %s shot.id = %s\n"
                             % (pid, self.id)))

class shot_stage_in(shot_stage):
    """
    stage in shot. send file from local host to the remote host.
    this is done by essentially

       gxpc e -g worker_gupid 'cat > target_file' < src_file
    """
    def __init__(self, server, run, resources, filename):
        Shot.__init__(self, server, run, resources)
        self.filename = filename
        self.cmd = "cat > %s" % filename

    def setup_redirect(self):
        try:
            in_fd = os.open(self.filename, os.O_RDONLY)
        except OSError,e:
            Es("xmake: %s : %s\n" % (self.filename, e.args,))
            return -1
        os.dup2(in_fd, 0)
        os.close(in_fd)
        return 0                        # go ahead

class shot_stage_out(shot_stage):
    """
    stage out shot.
    """
    def __init__(self, server, run, resources, filename):
        Shot.__init__(self, server, run, resources)
        self.filename = filename
        self.cmd = "cat < %s" % filename

    def setup_redirect(self):
        if os.path.exists(self.filename):
            return 1                    # nothing to do
        try:
            out_fd = os.open(self.filename, os.O_WRONLY|os.O_CREAT|os.O_TRUNC, 0644)
        except OSError,e:
            Es("xmake: %s : %s\n" % (self.filename, e.args,))
            return -1                   # error
        os.dup2(out_fd, 1)
        os.close(out_fd)
        return 0

class shot_rexec(Shot):
    """
    real shot on a remote node
    """
    def __init__(self, server, run, resources, cmd):
        Shot.__init__(self, server, run, resources)
        self.cmd = cmd

    def shot(self, cur_time, emulate):
        """
        send gxpc command to the target man
        """
        Shot.shot(self, cur_time)
        self.id = Shot.counter.get()
        if emulate:
            cmd = "exit 0"
        else:
            cmd = self.cmd
        self.start_time = cur_time
        # build gxpc command line
        cmdx = [self.server.opts.gxpc, "--save_session", "0",
                "e", "-g", self.run.man.name, "--tid", self.server.tid,
                "--rid", self.id, "--keep_connection", "0",
                "--dir", self.run.work.cwd ]
        for var_val in self.run.work.envs:
            cmdx.append("--export")
            cmdx.append(var_val)
        cmdx.append(cmd)
        if self.server.logfp:
            self.server.LOG(("dispatching job to %s (%s)\n"
                             % (self.run.man.name, cmdx)))
        # really run process
        pid = os.fork()
        if pid == 0:
            self.server.close_fds()
            os.execvp(cmdx[0], cmdx)
        if self.server.logfp:
            self.server.LOG(("child process pid = %s shot.id = %s\n"
                             % (pid, self.id)))
    
class shot_lexec(Shot):
    """
    real shot on the local host
    """
    def __init__(self, server, run, resources, cmd):
        Shot.__init__(self, server, run, resources)
        self.cmd = cmd

    def shot(self, cur_time, emulate):
        Shot.shot(self, cur_time)
        if emulate:
            cmd = "exit 0"
        else:
            cmd = self.cmd
        self.start_time = cur_time
        cmdx = [ "sh", "-c", cmd ]
        if self.server.logfp:
            self.server.LOG(("locally executing %s (%s)\n" % (self.cmd, cmdx)))
        pid = os.fork()
        if pid == 0:
            self.server.close_fds()
            for var_val in self.run.work.envs:
                [ var,val ] = string.split(var_val, "=", 1)
                os.environ[var] = val
            cwd = os.path.expanduser(os.path.expandvars(self.run.work.cwd))
            os.chdir(cwd)
            os.execvp(cmdx[0], cmdx)
        self.id = pid
        if self.server.logfp:
            self.server.LOG(("child process pid = %s shot.id = %s\n"
                             % (pid, self.id)))


class Run:
    def __init__(self, server, work):
        """
        a work has been dispatched to man at time t
        """
        self.server = server            # xmake_server object
        self.work = work                # the parent work this run is for
        self.man = None                 # set by find_matches
        self.shots = []                 # filled by make_run
        self.status = None
        self.time_start = None          # set by the first shot's shot
        self.time_end = None

    def xxx_abort(self, status, cur_time):
        self.time_end = cur_time
        self.status = status
        man = self.man
        _,p = self.server.parallelism[-1]
        self.server.parallelism.append((cur_time, p - 1))
        if self.server.logfp:
            self.server.LOG("man %s now dead\n" % man.name)
        self.work.finish(status, man)

    def finish(self, status, cur_time):
        self.time_end = cur_time
        self.status = status
        man = self.man
        # man is None if this shot is aborted
        if man:
            if man.live:
                self.server.free_men.append(man) # this man is now free
                if self.server.logfp:
                    self.server.LOG("man %s now free\n" % man.name)
                man.running.remove(self)
            else:
                if self.server.logfp:
                    self.server.LOG("man %s now dead\n" % man.name)
                if self in man.running:
                    man.running.remove(self)
        else:
            # this happens when we reach the time limit and this work
            # must be aborted before dispatched to any man
            assert (status == self.server.status_time_limit), status
        self.work.finish(status, man)

class x_work_translator:
    def __init__(self, server):
        """
        a file f enters files table when it appears for
        the first time.  files_being_written[f] = (None, translated_name).
        at the same time, the work enters works table.
        works[w] = list of files being written by that work.
        when the work finished, these files enter files_written.
        """
        self.server = server
        # original filename -> (man_name/None, translated_name)
        self.files = {}
        # work -> list of files being written by that work
        self.works = {}
        
    def modify_run(self, run):
        if self.server.opts.stage_in is None: return
        work = run.work
        files = {}
        stage_in = {}
        for shot in run.shots:
            if self.server.logfp:
                self.server.LOG("translating a shot '%s'\n" % shot.cmd)
            cmd_list = []
            for a in shlex.split(shot.cmd):
                man,a_ = self.files.get(a, (None, None))
                if man is None and a_ is None:
                    # appeared for the first time
                    a_ = re.sub("out/", "/tmp/tau/", a)
                    if a_ != a:
                        # record the fact that a is translated to a_,
                        # expecting file a_ will be created by the worker
                        # that executed the run
                        self.files[a] = (None, a_)
                        files[a] = a_   # a_ only for logging purpose
                else:
                    assert man is not None
                    stage_in[a_] = man
                cmd_list.append("'%s'" % a_)
            # which one do you think is better?
            # shot.cmd = string.join(cmd_list, " ")
            shot.cmd = re.sub("out/", "/tmp/tau/", shot.cmd)
            if self.server.logfp:
                self.server.LOG("translated into '%s'\n" % shot.cmd)
        if self.server.logfp:
            self.server.LOG(("files going to be written by this run = %s\n"
                             % files.values()))
            self.server.LOG("files read by this run = %s\n" % stage_in.keys())
        # record the fact that these files will be generated by this work
        assert run.work not in self.works, self.works[run.work]
        self.works[run.work] = files.keys()
        # add stage in command
        stage_in_cmds = []
        stage_in_cmd = self.server.opts.stage_in
        for filename,man in stage_in.items():
            s = shot_rexec(self.server, run, work.resources,
                           ("%s %s:%s %s"
                            % (stage_in_cmd, man.name, filename, filename)))
            stage_in_cmds.append(s)
        run.shots = stage_in_cmds + run.shots

    def work_finished(self, work, man):
        """
        the work has just been finished for the first time by man
        """
        if self.server.opts.stage_in is None: return
        for a in self.works[work]:
            man_,a_ = self.files[a]
            assert (man_ is None), man_
            if self.server.logfp:
                self.server.LOG("file %s will now be on %s\n" % (a_, man.name))
            self.files[a] = (man,a_)

class Work:
    def __init__(self, server, idx, req_time, conn,
                 envs, cwd, cmds, local, stage_ins, stage_outs, resources):
        """
        server : xmake_server object
        idx : sequence number of the work
        req_time : the time requested
        conn : connection to the client (socket object)
        envs : environment that must be passed to the command
        cwd  : working directory of the command
        cmds : list of command line
        local : 0/1 (1 if it should be executed locally)
        stage_ins : files to stage in 
        stage_outs : files to stage out
        resources : semaphores
        """
        self.server = server
        self.idx = idx                  # index
        self.req_time = req_time        # request time
        self.conn = conn                # connection to the mksh
        self.envs = envs       # envs to pass [ "MAKEFLAGS=..", "MAKELEVEL=.." ]
        self.cwd = cwd         # work dir
        self.cmds = cmds         # command
        self.local = local     # 1 or 0
        self.stage_ins = stage_ins      # files to stage in
        self.stage_outs = stage_outs    # files to stage out
        self.resources = resources      # resource spec
        self.status = None              # status if finished
        self.runs = []        # run records for the work. usually one

    def show_status(self):
        """
        for reporting
        """
        if self.status is None:
            run = self.runs[-1]
            if run.man is None:
                # not yet dispatched or in progress
                return ("waiting","-")
            else:
                return ("running", ("by %s" % self.runs[0].man.name))
        elif os.WIFEXITED(self.status):
            s = os.WEXITSTATUS(self.status)
            if s == 0:
                return ("success", ("exit %d" % s))
            else:
                return ("fail",  ("exit %d" % s))
        elif os.WIFSIGNALED(self.status):
            s = os.WTERMSIG(self.status)
            return ("killed", ("killed %d" % s))
        else:
            return ("unknown", ("??? %d" % self.status))

    def make_run(self):
        """
        make a run of shots
        """
        server = self.server
        res = self.resources
        cmds = self.cmds
        run = Run(server, self)
        shots = run.shots
        for f in self.stage_ins:
            # fix res
            shots.append(shot_stage_in(server, run, [ ("stage",1) ], f))
        if self.local:
            shot_constructor = shot_lexec
        else:
            shot_constructor = shot_rexec
        for cmd in cmds:
            shots.append(shot_constructor(server, run, res, cmd))
        for f in self.stage_outs:
            # fix res
            shots.append(shot_stage_out(server, run, [ ("stage",1) ], f))
        self.runs.append(run)
        # self.server.translator.modify_run(run)
        return run

    def finish(self, status, man):
        # this means man has been working on something,
        # and it has just finished
        # send notification to mksh
        if self.status is not None:
            if self.server.logfp:
                self.server.LOG(("warning: work finished twice %s, %s must have been dead\n"
                                 % (string.join(self.cmds, " "), man.name)))
            assert (man.live == 0), man.name
            return
        assert self.conn is not None
        msg = "%s\n" % os.WEXITSTATUS(status)
        try:
            self.conn.send(msg)
            self.conn.close()
        except socket.error,e:
            if e.args[0] == errno.EPIPE:
                Es(("xmake: could not send result to client: %s\n"
                    % (e.args,)))
            else:
                raise
        self.conn = None
        self.status = status
        # self.server.translator.work_finished(self, man)

        
local_man_name = "@local"

class xmake_server_conf:
    def __init__(self):
        self.cpu_count = []
        self.preprocess_cmds = []
        self.postprocess_cmds = []
        self.transform_cmds = []
        
    def parse(self, conf_file):
        if os.path.exists(conf_file):
            try:
                fp = open(conf_file, "rb")
            except IOError,e:
                Es("xmake: failed to open %s %s\n" % (conf_file, e.args))
                return
            for line in fp.readlines():
                line = string.strip(line)
                if line == "" or line[0] == "#": continue
                m = re.match("cpu\s+([^\s]+)\s+(\d+)", line)
                if m:
                    host = m.group(1)
                    n = int(m.group(2))
                    self.cpu_count.append((host, n))
                    continue
                m = re.match("preprocess\s+(.+)", line)
                if m:
                    cmd = string.strip(m.group(1))
                    self.preprocess_cmds.append((re.compile(".*"), cmd))
                    continue
                m = re.match("postprocess\s+(.+)", line)
                if m:
                    cmd = string.strip(m.group(1))
                    self.postprocess_cmds.append((re.compile(".*"), cmd))
                    continue
                m = re.match("transform\s+(.+)", line)
                if m:
                    cmd = string.strip(m.group(1))
                    self.transform_cmds.append((re.compile(".*"), cmd))
                    continue
            fp.close()

    def get_cpu_count(self, host):
        for regexp,n in self.cpu_count:
            if re.match(regexp, host):
                return n
        return 1

class work_attribute:
    # pattern of the command line in Makefile
    # command                  default -> distribute with no constraint
    # ===command               distribute
    # =(a,b,c)command          distribute with resource a,b,c
    # m.group(1) --> "=", "==", etc.
    # m.group(3) --> "a,b,c"
    # m.group(4) --> "command"
    pat = re.compile("(=+)(\(([^\)]*)\))?(.*)", re.DOTALL)
    def __init__(self):
        self.local = 0
        self.stage_ins = []
        self.stage_outs = []
        self.resources = []

class xmake_state_recorder:
    def __init__(self, opts, server):
        self.opts = opts
        self.server = server
    
    def LOG(self, s):
        self.server.LOG(s)

    def cur_time(self):
        return self.server.cur_time()
        
    def mk_temp(self, state):
        n = 10**7 - 1
        n_retries = 10
        directory,base = os.path.split(state)
        for i in range(0, n_retries):
            tmp_base = ("_%d_%07d_%s"
                        % (os.getpid(), random.randint(0, n), base))
            tmp = os.path.join(directory, tmp_base)
            try:
                wp = open(tmp, "wb")
                return tmp,wp           # OK, return
            except IOError,e:
                if i + 1 < n_retries and e.args[0] == errno.EPERM:
                    self.LOG("write op to %s failed, retry\n" % tmp)
                    # this sometimes happens with sshfs ..., worth retrying...
                    continue
                raise                   # raise other error as usual

    def gen_reload_header(self, finished):
        if finished or self.opts.auto_update_interval == 0:
            return ""
        else:
            return (r"""<meta http-equiv="refresh" content="%d"/>"""
                    % self.opts.auto_update_interval)

    def gen_default_style(self):
        return r"""<style>
<!--
h1 {
  background-color:#ccc;
}
table {
 margin:0px;
 border-style:solid;
 border-width:1px;
}
td {
  margin:0px;
  border-style:solid;
  border-width:1px;
}
td.running {
  background-color:#ff8;
}
td.success {
  background-color:#cff;
}
td.fail {
  background-color:#fc8;
}
td.killed {
  background-color:#fc8;
}
td.unknown {
  background-color:#fc8;
}
td.waiting {

}
td.man_free {
  background-color:#cff;
}
td.man_working {
  background-color:#ff8;
}
td.man_dead {
  background-color:#f88;
}
-->
</style>
"""

    def gen_header_trailer(self, finished):
        reload = self.gen_reload_header(finished)
        default_style = self.gen_default_style()
        header = (r"""<html>
<head>
%s
%s
<!-- you may have this file to overwrite default style -->
<link rel="stylesheet" href="state.css" type="text/css"/>
</head>
<body>
""" % (reload, default_style))
        trailer = r"""</body>
</html>
"""
        return header,trailer

    def status_to_str(self, status):
        if status is None:
            return ("running","running")
        elif os.WIFEXITED(status):
            s = os.WEXITSTATUS(status)
            if s == 0:
                return ("success",("exit %d" % s))
            else:
                return ("fail",("exit %d" % s))
        elif os.WIFSIGNALED(status):
            return ("killed", ("killed %d" % os.WTERMSIG(status)))
        else:
            return ("unknown", ("unknown %s" % status))

    def gen_basic_info(self, cur_time):
        server = self.server
        mk_class,mk_status = self.status_to_str(server.make_status)
        gxpc_class,gxpc_status = self.status_to_str(server.gxpc_status)
        return (r'''<a name="Basic info">
<h1>Basic info</h1>
<a href="#">page top</a><br><br>
<table class="basic_info">
<tr><td>command line</td><td>%s</td></tr>
<tr><td>master hostname</td><td>%s</td></tr>
<tr><td>pid</td><td>%s</td></tr>
<tr><td>start time</td><td>%s</td></tr>
<tr><td>elapsed time (sec)</td><td>%.2f</td></tr>
<tr><td>waiting / total jobs</td><td>%d / %d</td></tr>
<tr><td>free / total workers</td><td>%d / %d</td></tr>
<tr><td>xmake args</td><td>%s</td></tr>
<tr><td>make args</td><td>%s</td></tr>
<tr><td>make pid</td><td>%s</td></tr>
<tr><td>make status</td><td class="%s">%s</td></tr>
<tr><td>socket</td><td>%s</td></tr>
<tr><td>gxpc pid</td><td>%s</td></tr>
<tr><td>gxpc tid</td><td>%s</td></tr>
<tr><td>gxpc status</td><td>%s</td></tr>
<tr><td>gxpc fd</td><td>%s</td></tr>
</table>
''' % (server.sys_argv,
       server.hostname,
       os.getpid(), 
       time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(server.start_t)),
       server.cur_time(),
       len(server.shots_todo), len(server.works),
       len(server.free_men), len(server.men),
       server.xmake_args, server.make_args, 
       server.make_pid, mk_class, mk_status,
       server.so_name, 
       server.gxpc_pid, server.tid, gxpc_status,
       server.gxpc_fd))

    def mk_lnk(self, f, from_dir):
        real_f = os.path.realpath(f)
        real_from_dir = os.path.realpath(from_dir)
        common = os.path.commonprefix([real_f, real_from_dir])
        d = real_f
        base = ""
        # d,base = os.path.split(real_f)
        relative_path = base
        for i in range(100):
            assert i < 99, (0, f, from_dir, real_f, real_from_dir,
                            common, d, base, relative_path)
            try:
                if os.path.samefile(common, d): break
            except OSError,e:
                if e.args[0] == errno.ENOENT: return f
                raise
            d,base = os.path.split(d)
            relative_path = os.path.join(base, relative_path)
        d = real_from_dir
        for i in range(100):
            assert i < 99, (1, f, from_dir, real_f, real_from_dir,
                            common, d, base, relative_path)
            try:
                if os.path.samefile(common, d): break
            except OSError,e:
                if e.args[0] == errno.ENOENT: return f
                raise
            d,base = os.path.split(d)
            relative_path = os.path.join("..", relative_path)
        return ('<a href="%s">%s</a>' % (relative_path, f))

    def modify_cmd(self, cmd):
        option_regexps = [ "\-\-[^ ]+=",
                           "[\+\-][^ ]{2}", "[\+\-][^ ]",
                           "" ]
        arg_splitter = ","

        A = []
        try:
            args = shlex.split(cmd)
        except ValueError:
            # any error happens -> do not
            # bother to modify cmd
            return cmd
        for arg in args:
            C = []
            for opt in option_regexps:
                m = re.match(opt, arg)
                if m:
                    found = 0
                    files = []
                    for f in string.split(arg[m.end():], arg_splitter):
                        if os.path.exists(f):
                            found = found + 1
                            files.append(self.mk_lnk(f, self.opts.state_dir))
                        else:
                            files.append(f)
                    C.append((found,
                              m.group() + string.join(files, arg_splitter)))
                else:
                    C.append((0, arg))
            _,arg = max(C)
            if " " in arg or "\t" in arg:
                A.append("'%s'" % arg)
            else:
                A.append(arg)
        return string.join(A, " ")

    def modify_cmds(self, cmds):
        cmds_ = []
        for cmd in cmds:
            cmds_.append(self.modify_cmd(cmd))
        return cmds_
    
    def gen_heading_aux(self, label, states, jobs_txt, jobs_txt_sz, idx):
        wp = cStringIO.StringIO()
        wp.write((r'''<a name="%s">
<h1>%s (%d/%d)</h1>
<a href="#">page top</a><br>
''' % (label, label, idx+1, len(states))))
        if idx - 1 >= 0:
            wp.write(('<a href="%s#%s">prev</a> ' % (states[idx - 1], label)))
        if idx + 1 < len(states):
            wp.write(('<a href="%s#%s">next</a> ' % (states[idx + 1], label)))
        for i in range(len(states)):
            wp.write('<a href="%s#%s">%d</a> ' % (states[i], label, i + 1))
        wp.write("<br>")
        if jobs_txt is not None:
            wp.write(('<a href="%s">all jobs (%d bytes)</a> ' 
                      % (jobs_txt, jobs_txt_sz)))
        return wp.getvalue()

    
    def gen_failed_heading(self, states, jobs_txt, jobs_txt_sz, idx):
        return self.gen_heading_aux("Failed Jobs", 
                                    states, jobs_txt, jobs_txt_sz, idx)

    def gen_long_heading(self, states, jobs_txt, jobs_txt_sz, idx):
        return self.gen_heading_aux("Long Jobs", 
                                    states, jobs_txt, jobs_txt_sz, idx)

    def gen_recent_heading(self, states, jobs_txt, jobs_txt_sz, idx):
        return self.gen_heading_aux("Recent Jobs", 
                                    states, jobs_txt, jobs_txt_sz, idx)

    def gen_works_aux(self, label, works, cur_time):
        wp = cStringIO.StringIO()
        wp.write(r'''<table class="works">
<tr>
<td>idx</td>
<td>command</td>
<td>queued at</td>
<td>started at</td>
<td>finished at</td>
<td>executed by</td>
<td>turn around time</td>
<td>status</td>
</tr>''')
        for w in works:
            queued_t = time.ctime(w.req_time + self.server.start_t)
            run = w.runs[-1]
            s = run.time_start
            e = run.time_end
            start_t = "<br>"
            end_t = "<br>"
            elapsed = "<br>"
            man = "<br>"
            if s is not None:
                man = run.man.name
                start_t = time.ctime(s + self.server.start_t)
                if e is not None:
                    end_t = time.ctime(e + self.server.start_t)
                    elapsed = "%.2f" % (e - s)
                else:
                    elapsed = "%.2f" % (cur_time - s)
            cls,sts = w.show_status()
            cmds = string.join(self.modify_cmds(w.cmds), "<br><br>")
            wp.write(('<tr>'
                      '<td>%d</td> '
                      '<td>%s</td> '
                      '<td>%s</td> '
                      '<td>%s</td> '
                      '<td>%s</td> '
                      '<td>%s</td> '
                      '<td>%s</td> '
                      '<td class="%s">%s</td> '
                      '</tr>\n'
                      % (w.idx, cmds,
                         queued_t, start_t, end_t,
                         man, elapsed, cls, sts)))
        wp.write('</table>\n')
        return wp.getvalue()

    def chunk_list(self, L, g):
        LL = []
        for i in range(0, len(L), g):
            LL.append(L[i:i+g])
        return LL

    def get_recent_works(self, cur_time):
        works = self.server.works
        if self.opts.max_records >= 0:
            works = works[-self.opts.max_records:]
        return self.chunk_list(works, self.opts.max_records_in_page)

    def get_failed_works(self, cur_time):
        works = []
        for w in self.server.works:
            if w.status is not None and w.status != 0: # None and non-zero int
                works.append(w)
        if self.opts.max_records >= 0:
            works = works[-self.opts.max_records:]
        return self.chunk_list(works, self.opts.max_records_in_page)

    def get_long_works(self, cur_time):
        t_works = []
        for w in self.server.works:
            if len(w.runs) == 0: continue
            time_start = w.runs[-1].time_start
            if time_start is None: continue
            time_end = w.runs[-1].time_end
            if time_end is None: time_end = cur_time
            t_works.append((time_start - time_end, w))
        t_works.sort()
        if self.opts.max_records >= 0:
            t_works = t_works[:self.opts.max_records]
        works = []
        for t,w in t_works:
            works.append(w)
        return self.chunk_list(works, self.opts.max_records_in_page)

    def gen_recent_table(self, works, cur_time):
        return self.gen_works_aux("Recent Jobs", works, cur_time)

    def gen_failed_table(self, works, cur_time):
        return self.gen_works_aux("Failed Jobs", works, cur_time)

    def gen_long_table(self, works, cur_time):
        return self.gen_works_aux("Long Jobs", works, cur_time)

    def gen_works_in_comments(self, cur_time):
        wp = cStringIO.StringIO()
        # wp.write('<!--\n')
        wp.write(('idx\t'
                  'command\t'
                  'queued at\t'
                  'started at\t' 
                  'finished at\t'
                  'executed by\t'
                  'turn around time\t'
                  'status\n'))

        for w in self.server.works:
            queued_t = time.ctime(w.req_time + self.server.start_t)
            run = w.runs[-1]
            s = run.time_start
            e = run.time_end
            start_t = ""
            end_t = ""
            elapsed = ""
            man = ""
            if s is not None:
                man = run.man.name
                start_t = time.ctime(s + self.server.start_t)
                if e is not None:
                    end_t = time.ctime(e + self.server.start_t)
                    elapsed = "%.2f" % (e - s)
                else:
                    elapsed = "%.2f" % (cur_time - s)
            cls,sts = w.show_status()
            cmds = string.join(w.cmds, " && ")
            wp.write(('%d\t'
                      '%s\t'
                      '%s\t'
                      '%s\t'
                      '%s\t'
                      '%s\t'
                      '%s\t'
                      '%s\n'
                      % (w.idx, cmds,
                         queued_t, start_t, end_t,
                         man, elapsed, sts)))
        # wp.write('-->\n')
        return wp.getvalue()
    
    def gen_men(self, cur_time):
        """
        generate worker state
        """
        wp = cStringIO.StringIO()
        men = self.server.men.items()
        men.sort()
        wp.write(r'''<a name="Worker States">
<h1>Worker States</h1>
<a href="#">page top</a><br><br>
last_ping_time = %.3f<br>
<table class="men">
<tr><td class="men_header">worker name</td><td>jobs</td><td>last heard</td><td>status</td></tr>
''' % self.server.pinger.last_ping_time)
        for name,man in men:
            n_running = len(man.running)
            if n_running == 0:
                if man.live:
                    cls = "man_free"
                else:
                    cls = "man_dead"
                wp.write(('<tr><td>%s</td><td>%s</td>'
                          '<td>%.3f</td><td class="%s">-</td></tr>\n'
                          % (name, len(man.runs),
                             man.last_heartbeat_time, cls)))
            else:
                if man.live:
                    cls = "man_working"
                else:
                    cls = "man_dead"
                i = 0
                for run in man.running:
                    cmds = string.join(run.work.cmds, "<br><br>")
                    if i == 0:
                        wp.write(('<tr>'
                                  '<td rowspan=%d>%s</td>'
                                  '<td rowspan=%d>%s</td>'
                                  '<td rowspan=%d>%.3f</td>'
                                  '<td class="%s">%s</td>'
                                  '</tr>\n'
                                  % (n_running, man.name,
                                     n_running, len(man.runs),
                                     n_running, man.last_heartbeat_time,
                                     cls, cmds)))
                    else:
                        wp.write(('<tr><td class="man_working">%s</td></tr>\n'
                                  % cmds))
                    i = i + 1
        wp.write('</table>\n')
        return wp.getvalue()

    def run_gnuplot(self, cur_time):
        gpl = os.path.join(self.opts.state_dir, self.opts.parallelism_gpl)
        err = os.path.join(self.opts.state_dir, self.opts.gnuplot_err)
        img = os.path.join(self.opts.state_dir, self.opts.parallelism_image)
        wp = open(gpl, "wb")
        wp.write(r"""set terminal png
set style fill solid
plot '-' with boxes
""")
        for t,p in self.server.parallelism:
            wp.write('%.3f %d\n' % (t, p))
        _,p = self.server.parallelism[-1]
        wp.write('%.3f %d\n' % (cur_time, p))
        wp.write('e\n')
        wp.close()
        cmd = "gnuplot %s 2> %s > %s" % (gpl, err, img)
        status = os.system(cmd)
        fp = open(err, "rb")
        err = fp.read()
        fp.close()
        self.LOG("gnuplot status = %s\n" % status)
        if err != "":
            self.LOG("error from gnuplot:\n%s" % err)

    def run_cmd(self, cmd):
        outs = []
        fp = os.popen(cmd)
        while 1:
            try:
                out = fp.read()
                if out == "": break
                outs.append(out)
            except IOError,e:
                if e.args[0] != errno.EINTR:
                    raise
        status = fp.close()
        self.LOG("uptime status = %s\n" % status)
        return string.join(outs, "")
        
    def run_uptime(self):
        self.LOG("getting uptime stat\n")
        return self.run_cmd("uptime")

    def run_vmstat(self):
        self.LOG("getting vmstat stat\n")
        return self.run_cmd("vmstat")

    def gen_table_of_contents(self, states, jobs_txt, jobs_txt_sz, cur_time):
        wp = cStringIO.StringIO()
        wp.write((r'''<a name="Table of Contents">
<h1>Contents</h1>
<ul>
<li><a href="#System Stats">System States</a>
<li><a href="#Basic info">Basic info</a>
<li><a href="#Parallelism">Parallelism</a>
<li>Jobs
<ul>
  <li><a href="%s">All Jobs in txt (%d bytes)</a>
  <li><a href="#Failed Jobs">Failed Jobs</a>
  <li><a href="#Long Jobs">Long Jobs</a>
  <li><a href="#Recent Jobs">Recent Jobs</a>
</ul>
<li><a href="#Worker States">Worker States</a>
''' % (jobs_txt, jobs_txt_sz)))
        wp.write('<li>')
        for i in range(len(states)):
            wp.write('<a href="%s">%d</a> ' % (states[i], i + 1))
        wp.write('<br>\n')
        wp.write('</ul>')
        return wp.getvalue()

    def gen_stat(self, cur_time):
        uptime = self.run_uptime()
        vmstat = self.run_vmstat()
        return (r'''<a name="System Stats">
<h1>System Stats</h1>
<a href="#">page top</a><br><br>
<h2>vmstat</h2>
<pre>%s</pre>
<h2>uptime</h2>
<pre>%s</pre>
''' % (vmstat, uptime))

    def gen_parallelism(self, cur_time):
        self.LOG("generating parallelism profile\n")
        self.run_gnuplot(cur_time)
        return ('''<a name="Parallelism">
<h1>Parallelism</h1>
<a href="#">page top</a><br><br>
<p>if the following image is broken, gnuplot may have gotten an error</p>
<ul>
<li><a href="%s">gnuplot source</a>
<li><a href="%s">gnuplot error</a>
</ul>
<a href="%s"><img src="%s" width=640></a><br>
''' % (self.opts.parallelism_gpl, self.opts.gnuplot_err, 
       self.opts.parallelism_image, self.opts.parallelism_image))


    def gen_elapsed_time(self, cur_time):
        dt = self.cur_time() - cur_time
        return ("<br>(took %.3f sec to generate up to this point)<br>" % dt)

    def paranoia_rename(self, src, dst):
        ino = os.stat(src)[stat.ST_INO]
        self.LOG("renaming %s (ino=%d) -> %s\n" % (src, ino, dst))
        os.rename(src, dst)
        ok = 1
        if os.path.exists(src):
            self.LOG("??? src %s still exists!\n" % src)
            ok = 0
        if os.path.exists(dst):
            d_ino = os.stat(dst)[stat.ST_INO]
            if d_ino != ino:
                self.LOG("??? dst inode number (%d) != original inode number (%d)\n" % (d_ino, ino))
                ok = 0
        else:
            self.LOG("??? dst %s does not exist\n" % dst)
            ok = 0
        if ok:
            self.LOG("OK, successfully renamed\n")
    

    def gen_state_filenames(self, state, n):
        """
        /foo/bar/state.html 
        --> job_txt = /foo/bar/state.txt
            states = [ /foo/bar/state.html,
                       /foo/bar/state_2.html,
                       /foo/bar/state_3.html ]
        """
        dirname,basename = os.path.split(state)
        base_ext = string.rsplit(basename, ".", 1)
        if len(base_ext) == 1:
            [ base ] = base_ext
            ext = ""
        else:
            [ base,ext ] = base_ext
            ext = ".%s" % ext
        jobs_txt = os.path.join(dirname, ("%s.txt" % base))

        states = []
        for i in range(n):
            if i > 0:
                basename = ("%s_%d%s" % (base, i + 1, ext))
            states.append(os.path.join(dirname, basename))
        return jobs_txt,states

    def record_state(self, finished):
        if self.opts.state == "": return
        state = os.path.join(self.opts.state_dir, self.opts.state)
        self.LOG("generating state file (%s)\n" % state)
        cur_time = self.cur_time()
        # -------- count work and determine no. of pages -------- 
        failed_works = self.get_failed_works(cur_time)
        long_works = self.get_long_works(cur_time)
        recent_works = self.get_recent_works(cur_time)
        n_pages = max(len(failed_works), len(long_works), len(recent_works))
        # -------- generate all filenames --------
        jobs_txt,states = self.gen_state_filenames(state, n_pages)
        # -------- generate all works and get its size --------
        jobs = self.gen_works_in_comments(cur_time)
        jobs_txt_sz = len(jobs)

        # generate fixed part
        # -------- header/trailer --------
        header,trailer = self.gen_header_trailer(finished)
        # -------- index --------
        index = self.gen_table_of_contents(states, jobs_txt, jobs_txt_sz, 
                                           cur_time)
        # -------- load avg and vmstat --------
        stat = self.gen_stat(cur_time)
        # -------- basic info --------
        basic_info = self.gen_basic_info(cur_time)
        # -------- parallelism --------
        parallelism = self.gen_parallelism(cur_time)
        # -------- men state --------
        men = self.gen_men(cur_time)
        

        for i in range(n_pages):
            tmp,wp = self.mk_temp(states[i])
            wp.write(header)
            wp.write(index)
            wp.write(stat)
            wp.write(basic_info)
            wp.write(parallelism)
            # ---- failed jobs ----
            wp.write(self.gen_failed_heading(states, jobs_txt, jobs_txt_sz, i))
            if i < len(failed_works):
                wp.write(self.gen_failed_table(failed_works[i], cur_time))
                wp.write(self.gen_elapsed_time(cur_time))
            # ---- long jobs ----
            wp.write(self.gen_long_heading(states, jobs_txt, jobs_txt_sz, i))
            if i < len(long_works):
                wp.write(self.gen_long_table(long_works[i], cur_time))
                wp.write(self.gen_elapsed_time(cur_time))
            # ---- recent jobs ----
            wp.write(self.gen_recent_heading(states, jobs_txt, jobs_txt_sz, i))
            if i < len(recent_works):
                wp.write(self.gen_recent_table(recent_works[i], cur_time))
                wp.write(self.gen_elapsed_time(cur_time))
            # ---- worker stats ----
            if i == 0:
                wp.write(men)
                wp.write(self.gen_elapsed_time(cur_time))
            wp.write(trailer)
            wp.close()
            self.paranoia_rename(tmp, states[i])
        tmp,wp = self.mk_temp(jobs_txt)
        wp.write(jobs)
        self.paranoia_rename(tmp, jobs_txt)
        dt = self.cur_time() - cur_time
        self.LOG(("took %.3f sec to generate state file (%s)\n"
                  % (dt, state)))

    def record_state_x(self, finished):
        if self.opts.state == "": return
        state = os.path.join(self.opts.state_dir, self.opts.state)
        self.LOG("generating state file (%s)\n" % state)
        tmp,wp = self.mk_temp(state)
        cur_time = self.cur_time()
        
        header,trailer = self.get_header_trailer(finished)
        # -------- header --------
        wp.write(header)
        # -------- index --------
        self.write_table_of_contents(cur_time, wp)
        # -------- load avg and vmstat --------
        self.write_stat(cur_time, wp)
        self.write_elapsed_time(cur_time, wp)
        # -------- basic info --------
        self.write_basic_info(cur_time, wp)
        self.write_elapsed_time(cur_time, wp)
        # -------- parallelism --------
        self.write_parallelism(cur_time, wp)
        self.write_elapsed_time(cur_time, wp)
        # -------- work --------
        self.write_failed_works(cur_time, wp)
        self.write_elapsed_time(cur_time, wp)
        self.write_long_works(cur_time, wp)
        self.write_elapsed_time(cur_time, wp)
        self.write_recent_works(cur_time, wp)
        self.write_elapsed_time(cur_time, wp)
        # -------- men state --------
        self.write_men(cur_time, wp)
        self.write_elapsed_time(cur_time, wp)
        # -------- all works in comments --------
        self.write_works_in_comments(cur_time, wp)
        self.write_elapsed_time(cur_time, wp)
        # -------- trailer --------
        wp.write(trailer)
        wp.close()
        self.paranoia_rename(tmp, state)
        dt = self.cur_time() - cur_time
        if self.server.logfp:
            self.LOG("took %.3f sec to generate state file (%s)\n" % (dt, state))

    
class Pinger:
    def __init__(self, server):
        self.server = server
        self.id = 0
        self.ping_pid = None
        self.last_ping_time = 0
        self.ping_interval = 5.0

    def get_rid(self):
        x = self.id
        self.id = x + 1
        return "z%d" % x
        
    def ping_all(self, cur_time):
        if self.last_ping_time + self.ping_interval >= cur_time:
            return 0
        if self.server.logfp:
            self.server.LOG("periodic ping to all workers\n")
        if self.ping_pid is not None:
            if self.server.logfp:
                self.server.LOG(("ping (pid = %d) taking so much time,"
                                 " trying to kill it\n" % self.ping_pid))
            try:
                os.kill(self.ping_pid, signal.SIGKILL)
            except OSError,e:
                if self.server.logfp:
                    self.server.LOG("os.kill: %s\n" % (e.args,))
            return 0
        cmdx = [self.server.opts.gxpc, "--save_session", "0",
                "e", "--tid", self.server.tid,
                "--rid", self.get_rid(), "--keep_connection", "0", ":" ]
        if self.server.logfp:
            self.server.LOG("ping by '%s'\n" % string.join(cmdx, " "))
        pid = os.fork()
        if pid == 0:
            self.server.close_fds()
            os.execvp(cmdx[0], cmdx)
        self.ping_pid = pid             # set to None in handle_child_death
        self.last_ping_time = cur_time
        return 1

class xmake_server:
    """

    a server that accepts a connection from mksh (which was probably
    invoked by make), dispatches received command lines to free
    workers, and receives the result.

    """
    def __init__(self):
        # xmake_cmd_opts object
        self.sys_argv = None
        self.opts = None
        # args passed through GNU make
        self.make_args = None
        # args this process takes (after '--')
        self.xmake_args = None
        # start time
        self.start_t = None
        # file object for the log
        self.logfp = None
        # gxp task id of everything
        self.tid = None
        # for e --persistent 1 ...,
        # its command line, pid, exit status, pipe
        self.gxpc_cmd = None
        self.gxpc_pid = None
        self.gxpc_status = None
        self.gxpc_fd = None
        self.gxpc_partial_msg = None    # incomplete line
        # UNIX domain socket to accept connect from mksh
        self.so = None
        self.so_name = None             # so's path name
        #
        self.cleaning = 0
        # sigchild handling
        # a sig handler writes to child_wfd,
        # and the main thread receives it from rfd
        self.child_rfd = None
        self.child_wfd = None
        self.n_sigchild_written = None
        self.n_sigchild_read = None
        # pid of GNU make process
        self.make_pid = None
        self.make_status = None
        # list of all works 
        self.works = None
        self.shots_todo = None
        self.shots = None
        self.matches = None
        # dict of all men (man name -> man)
        self.men = None
        self.local_man = None
        # list of free men
        # multiple entries for multi-core men
        self.free_men = None
        # record_state timing control
        self.rec = None
        self.last_record_time = None
        self.next_record_time_1 = None
        self.next_record_time_2 = None
        # semaphore for concurrency control
        self.semaphores = None
        # parallelisim profile
        self.parallelism = None         # list of (t, p)s
        # execs[dispatch_id] = exec_state
        self.execs = None
        # self.translator = work_translator(self)
        self.interrupted = None
        self.hostname = None
        #
        self.pinger = Pinger(self)

    def safe_int(self, x):
        try:
            return int(x)
        except ValueError,e:
            return None

    def parse_args(self, sys_argv):
        """
        parse command line args
        argv = sys_argv
        return value
        -1 on failure
         0 on success
        """
        make_args = []
        xmake_args = []
        args = (make_args, xmake_args)
        self.sys_argv = sys_argv
        for a in sys_argv[1:]:
            if a == "--":
                # swap
                args = (args[1],args[0])
            else:
                args[0].append(a)
        xmake_opts = xmake_cmd_opts()
        if xmake_opts.parse(xmake_args) == -1:
            return -1
        self.opts = xmake_opts
        self.rec = xmake_state_recorder(xmake_opts, self)
        self.make_args = make_args
        self.xmake_args = xmake_args

    def mk_semaphores(self):
        """
        make a dictionary of semaphore values
        (name -> count) from command lines (--sem x:n)
        """
        semaphores = { "local" : 1, "stage" : 10 }
        for sem in self.opts.sem:
            for se in string.split(sem, ","):
                sv = string.split(string.strip(se), ":", 1)
                if len(sv) == 1:
                    [ s ] = sv
                    v = 1
                else:
                    [ s,v ] = sv
                    v = self.safe_int(v)
                    if v is None:
                        Es(('xmake: gxpc make error: wrong argument to --sem "%s"\n'
                            % se))
                        return None
                if self.logfp:
                    self.LOG("semaphore: %s := %d\n" % (s, v))
                semaphores[s] = v
        return semaphores

    def cur_time(self):
        """
        current time relative to start time
        """
        if self.start_t is None:
            self.start_t = time.time()
            return 0.0
        else:
            return time.time() - self.start_t
    
    def open_LOG(self):
        """
        open log file for writing
        return -1 on failure, 0 on success
        """
        if self.opts.log != "":
            log = os.path.join(self.opts.state_dir, self.opts.log)
            try:
                self.logfp = open(log, "wb")
            except Exception,e:
                Es("xmake: %s : %s\n" % (log, e.args,))
                return -1
        if self.logfp:
            self.LOG("started at %.3f\n" % time.time())
        return 0

    def close_LOG(self):
        """
        open log file
        """
        if self.logfp:
            self.LOG("finished\n")
            self.logfp.close()
            
    def LOG(self, s):
        """
        write s to log
        """
        if self.logfp is not None:
            t = "xmake: %.3f: %s" % (self.cur_time(), s)
            if dbg>=2: Ws(t)
            self.logfp.write(t)
            self.logfp.flush()

    def get_user_name(self):
        """
        user name or id
        """
        user = os.environ.get("USER")
        if user is None:
            return "%s" % os.geteuid()
        else:
            return user

    def get_tmp_dir(self):
        """
        dir to make working dir in
        """
        return "/tmp"

    def mk_tmp_dir(self):
        """
        make a temporary directory like
        /tmp/xmake-tau
        """
        tmp = self.get_tmp_dir()
        dire = os.path.join(tmp, "xmake-%s" % self.get_user_name())
        try:
            os.mkdir(dire, 0700)
            ok = 1
        except OSError,e:
            if e.args[0] == errno.EEXIST:
                ok = 1
            else:
                ok = 0
        if ok == 0:
            Es("xmake: fatal: could not make a socket directory %s\n" % dire)
            return None
        if not os.access(dire, os.W_OK):
            Es("xmake: fatal: socket directory %s not writable\n" % dire)
            return None
        return dire
    
    def mk_server_socket(self):
        """
        make a socket under the temporary directory.
        /tmp/xmake-tau/so<pid>-xxxxxxx.

        set the name to GXP_MAKE_SO_NAME, to pass it to mksh 
        (child of GNU make).
        """
        dire = self.mk_tmp_dir()
        if dire is None: return None,None
        name = os.path.join(dire,
                            ("so%06d-%06d"
                             % (os.getpid(), random.randint(0, 1000000))))
        if self.logfp:
            self.LOG("making server socket on %s\n" % name)
        so = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        so.bind(name)
        so.listen(self.opts.qlen)
        os.chmod(name, 0600)
        os.environ["GXP_MAKE_SO_NAME"] = name
        if self.logfp:
            self.LOG("server listening on %s\n" % name)
        return so,name

    def check_resources(self, shot):
        for res,v in shot.resources:
            if self.semaphores.get(res, v) < v:
                return 0
        return 1
                        
    def commit_resources(self, shot):
        for res,v in shot.resources:
            val = self.semaphores.get(res)
            if val is not None: self.semaphores[res] = val - v

    def release_resources(self, shot):
        for res,v in shot.resources:
            val = self.semaphores.get(res)
            if val is not None: self.semaphores[res] = val + v

    def close_fds(self):
        for fd in [ self.gxpc_fd, self.child_wfd, self.child_rfd ]:
            if fd is not None: os.close(fd)
        if self.so is not None: self.so.close()

    def fast_readlines(self, fd):
        """
        read many bytes from fd and return a list
        of lines. partial lines are kept in
        self.gxpc_partial_msg
        """
        while 1:
            try:
                a = os.read(fd, 10000)
            except IOError,e:
                if e.args[0] == errno.EINTR:
                    continue    # retry
                else:
                    raise
            break
        A = string.split(a, "\n")
        if len(A) == 0:
            assert self.gxpc_partial_msg == ""
            return []
        else:
            X = self.gxpc_partial_msg
            A[0] = X + A[0]
            self.gxpc_partial_msg = A[-1]
            S = A[:-1]
            for s in S: assert s, (a, A, X, S)
            return S
            
    def recv_bytes(self, conn, n):
        msgs = []
        r = n
        while r > 0:
            try:
                m = conn.recv(r)
            except socket.error,e:
                if e.args[0] == errno.EINTR:
                    continue
                else:
                    raise
            if m == "": break
            msgs.append(m)
            r = r - len(m)
        if r == n:
            return ""                   # real EOF
        elif r > 0:
            return None                 # NG, broken
        else:
            return string.join(msgs, "")

    def recv_sz(self, conn):
        s = self.recv_bytes(conn, 10)
        if s == "" or s is None: return s
        return int(s)

    def recv_elem(self, conn):
        elem_len = self.recv_sz(conn)
        if elem_len is None or elem_len == "": return elem_len
        elem = self.recv_bytes(conn, elem_len)
        if elem is None or len(elem) != elem_len: return None
        return elem

    def recv_work_aux(self, conn):
        """
        receive a work from mksh.
        """
        attr_cmd = self.recv_elem(conn)
        if attr_cmd is None or attr_cmd == "": return None,None,None
        cwd = self.recv_elem(conn)
        if cwd is None or cwd == "": return None,None,None
        envs = []
        while 1:
            varval = self.recv_elem(conn)
            if varval == "": break
            if varval is None: return None,None,None
            envs.append(varval)
        return attr_cmd,cwd,envs

    def parse_attributes(self, attr_cmd):
        wa = work_attribute()
        m = work_attribute.pat.match(attr_cmd)
        if m is None: return (wa,attr_cmd)
        equals = m.group(1)             # "=", "===", etc.
        attr_str = m.group(3)      # "a,b,c" etc. resource spec string
        cmd = m.group(4)                # command ("hostname" etc.)
        if len(equals) > 1: wa.local = 1
        # parse "id:num,id:num,...,id:num"
        # and make [ ("id",n), ("id",n), ... ]
        if attr_str:
            for attr in string.split(attr_str, ","):
                # attr :  val=value
                var_val = string.split(string.strip(attr), "=", 1)
                if len(var_val) == 1:
                    var = "res"
                    [ val ] = var_val
                else:
                    [ var, val ] = var_val
                if var == "in":
                    wa.stage_ins.append(val)
                elif var == "out":
                    wa.stage_outs.append(val)
                elif var == "res":
                    wa.resources.append((val,1))
                elif var == "local":
                    wa.local = int(val)
                else:
                    Es("xmake: invalid resource spec in %s\n" % attr_cmd)
                    if self.logfp:
                        self.LOG("invalid resource spec in %s\n" % attr_cmd)
        if wa.local: wa.resources.append(("local", 1))
        return wa,cmd

    def apply_pre_post_processor(self, title, pat, cmd, transformer, D):
        if not pat.match(cmd): return None
        try:
            t = transformer % D
        except KeyError,e:
            key = e.args[0]
            Es(("xmake: %s %s contains invalid keyword %s (ignored)\n"
                % (title, t, key)))
            return None
        return t

    def apply_transformer(self, title, pat, cmd, transformer, D):
        if not pat.match(cmd): return cmd
        try:
            t = transformer % D
        except KeyError,e:
            key = e.args[0]
            Es(("xmake: %s %s contains invalid keyword %s (ignored)\n"
                % (title, t, key)))
            return None
        c = self.run_cmd(t)
        if c == "":
            Es("xmake: %s %s returns empty string (ignored)\n" % (title, t))
            return None
        else:
            return c

    def transform_work(self, work_idx, cmd):
        cmds = []
        unquoted_cmd = re.sub("(\'|\")", " ", cmd)
        D = { "idx" : work_idx, "cmd" : unquoted_cmd }
        E = { "idx" : work_idx, "cmd" : cmd }
        for p,t in self.conf.preprocess_cmds:
            c = self.apply_pre_post_processor("preprocess", p, cmd, t, D)
            if c is not None: cmds.append(c)
        for p,t in self.conf.transform_cmds:
            c = self.apply_transformer("transform", p, cmd, t, E)
            if c is not None:
                cmd = c
                E["cmd"] = cmd
        cmds.append(cmd)
        for p,t in self.conf.postprocess_cmds:
            c = self.apply_pre_post_processor("postprocess", p, cmd, t, D)
            if c is not None: cmds.append(c)
        return cmds

    def recv_work(self):
        """
        receive a work from a connection
        """
        conn,addr = self.so.accept()
        attr_cmd,cwd,envs = self.recv_work_aux(conn)
        attr,cmd = self.parse_attributes(attr_cmd)
        work_idx = len(self.works)
        cmds = self.transform_work(work_idx, cmd)
        
        work = Work(self, work_idx, self.cur_time(), conn,
                    envs, cwd, cmds, attr.local, attr.stage_ins,
                    attr.stage_outs, attr.resources)
        if self.logfp:
            self.LOG(("got work cmd=%s (modified to %s) cwd=%s env=%s "
                      "local=%s stage_ins=%s stage_outs=%s resources=%s\n"
                      % (cmd, cmds, cwd, envs, attr.local,
                         attr.stage_ins, attr.stage_outs, attr.resources)))
        self.shots_todo.append(work.make_run().shots[0])
        self.works.append(work)
        self.n_state_changes = self.n_state_changes + 1

    def recv_works(self):
        while 1:
            try:
                R = []
                R,_,_ = select.select([self.so], [], [], 0.0)
            except select.error,e:
                if e.args[0] == errno.EINTR:
                    self.LOG("select interrupted in recv_works\n")
                else:
                    raise
            if len(R) == 0: break
            self.recv_work()
        
    def recv_fins(self):
        """
        receive a termination notification of a single command from
        gxpc.
        (gupid, tid, src, rid, pid, status)
        hongo104-tau-2008-04-26-13-05-48-11662 tid_make_24108_9380 proc 1 13335 0
        """
        lines = self.fast_readlines(self.gxpc_fd)
        if len(lines) == 0:
            if self.logfp:
                self.LOG(("got EOF from notify channel %s\n" 
                          % self.gxpc_cmd))
            self.gxpc_fd = None
            return ""
        if self.logfp:
            self.LOG("got %d notifications\n" % len(lines))
        for line in lines:
            self.recv_fin(line)

    def recv_fin(self, line):
        """
        handle a message from gxpc saying a process has finished
        """
        if self.logfp:
            self.LOG("notified of a remote process termination %s\n" % line)
        [ man_name, tid, src_, rid, pid_, status ] = string.split(line)
        # [ man_name, _, _, _, _, status ] = string.split(line)
        assert man_name != ""
        man = self.men.get(man_name)
        cur_time = self.cur_time()
        if man is None:
            # the first msg from this man
            n = self.conf.get_cpu_count(man_name)
            if self.logfp:
                self.LOG("new man %s joined with %d cpus\n" % (man_name, n))
            man = Man(man_name, len(self.men), n, cur_time)
            self.men[man_name] = man
            for i in range(n):
                self.free_men.append(man)
            assert not self.shots.has_key(rid)
        else:
            shot = self.shots.get(rid)
            if shot:
                assert shot.id == rid, (shot.id, rid)
                self.handle_fin(shot, status)
            elif rid[0:1] == "z": # ugly way to know this is a reply to ping
                man.set_heartbeat(cur_time)
                if man.live:
                    if self.logfp:
                        self.LOG(("a heartbeat from a healthy worker %s\n"
                                  % man_name))
                else:
                    msg = ("a heartbeat from a worker %s who was once"
                           " considered dead (ignored)\n"
                           % man_name)
                    if self.logfp: self.LOG(msg)
                    Es("xmake: %s" % msg)
            else:
                if self.logfp:
                    self.LOG("rid %s not found in shots\n" % rid)
        self.n_state_changes = self.n_state_changes + 1
            
    def handle_fin(self, shot, status):
        # a working process has just finished.
        self.release_resources(shot)
        del self.shots[shot.id]
        if self.logfp:
            self.LOG("shot %s finished\n" % shot)
        cur_time = self.cur_time()
        _,p = self.parallelism[-1]
        self.parallelism.append((cur_time, p - 1))
        shot.finish(int(status), cur_time)
        
    def find_matches(self):
        fifo = 1
        if self.logfp:
            self.LOG("matching men and works\n")
        M = []                          # work -> man
        new_shots_todo = []
        while len(self.shots_todo) > 0:
            if fifo:
                shot = self.shots_todo.pop(0)
            else:
                shot = self.shots_todo.pop(-1)
            # check if work is executable meeting resource constraints
            # log becomes too large
            # self.LOG("finding match for shot '%s'\n" % shot)
            if self.logfp:
                if dbg>=2:
                    self.LOG("finding match for shot '%s'\n" % shot)
            if self.check_resources(shot) == 0:
                if self.logfp:
                    if dbg>=2:
                        self.LOG("hold due to insufficient resources\n")
                new_shots_todo.append(shot)
                continue
            if shot.run.man:
                # local or second or later shots
                if self.logfp:
		    self.LOG(("shot '%s' continues using %s\n"
                              % (shot, shot.run.man.name)))
                self.commit_resources(shot)
                M.append((shot, shot.run.man))
            else:
                # look for man who can execute it
                found = 0
                if shot.run.work.local:
                    found = 1
                    man = self.local_man
                else:
                    for man in self.free_men:
                        self.free_men.remove(man)
                        if man.live:
                            found = 1
                            break           # found match for man
                        else:
                            Es("xmake: dead man %s found in free_men queue\n" % man.name)
                if found:
                    if self.logfp:
                        self.LOG(("shot '%s' assignged %s\n"
                                  % (shot, man.name)))
                    self.commit_resources(shot)
                    shot.run.man = man  # assign man to run
                    man.running.append(shot.run)
                    man.runs.append(shot.run)
                    M.append((shot, man))
                else:
                    new_shots_todo.append(shot)
        # fifo or lifo?
        if fifo:
            pass
        else:
            new_shots_todo.reverse()
        self.shots_todo = new_shots_todo
        if self.logfp:
            self.LOG("%d job matches found\n" % len(M))
        return M
                    
    def dispatch(self):
        """
        dispatch some works, assuming there is a free worker
        and a work to execute.

        gxpc e -g <worker> --tid <tid> --keep_connection 0 '<cmd>'

        """
        if self.opts.no_dispatch_after is not None \
               and self.cur_time() > self.opts.no_dispatch_after:
            if self.logfp:
                self.LOG(("do not dispatch work after %.3f\n"
                          % self.opts.no_dispatch_after))
            return 0
        matches = self.find_matches()
        self.matches = self.matches + matches
        _,p = self.parallelism[-1]
        n = 0
        while len(self.matches) > 0:
            shot,man = self.matches.pop(0)
            cur_time = self.cur_time()
            shot.shot(cur_time, self.opts.emulate)
            n = n + 1
            self.n_state_changes = self.n_state_changes + 1
            self.parallelism.append((cur_time, p + n))
            self.shots[shot.id] = shot
            # check if a job is returning
            # may be too much overhead
            if n % 1000 == 0:
                try:
                    RR = []
                    RR,_,_ = select.select([ self.gxpc_fd ], [], [], 0.0)
                except select.error,e:
                    if e.args[0] == errno.EINTR:
                        if self.logfp:
                            self.LOG("select interrupted\n")
                if len(RR) > 0: break
            if self.n_sigchild_written - self.n_sigchild_read > 50:
                break
        if self.logfp:
            self.LOG("%d jobs dispatched\n" % n)
        
        cur_time = self.cur_time()
        self.check_all(cur_time)
        self.pinger.ping_all(cur_time)
        return n

    def check_all(self, cur_time):
        men = self.men.items()
        men.sort()
        for name,man in men:
            # local_man will never die
            if man is not self.local_man and man.live \
                   and man.last_heartbeat_time < self.pinger.last_ping_time \
                   and man.last_heartbeat_time < cur_time - 30.0:
                man.live = 0
                Es("xmake: no response from worker %s, jobs thrown "
                   "there will exit with %d\n"
                   % (name, self.opts.exit_status_worker_dead))
                for run in man.running[:]: # make a copy
                    run.finish(self.status_worker_dead, cur_time)
                    assert run not in man.running
                assert len(man.running) == 0

    def run_persistent_e(self, tid):
        """
        create the task to which processes will be added later.
        invoked once in the beginning.

        return command_line,pid,file_object_to_hear_from_it
        """
        # child gxpc write process terminatation events to w.
        # parent gets them from r
        r,w = os.pipe()
        # r0 becomes stdin of the child
        # the parent immediately closes w0
        # net effect is gxpc immediately receives EOF from its stdin
        r0,w0 = os.pipe()
        cmd = [ self.opts.gxpc, "e", "--tid", tid, "--persist", "1",
                "--notify_proc_exit", ("%d" % w) ]
        pid = os.fork()
        if pid == 0:
            self.close_fds()
            # os.setpgrp()
            os.close(r)
            os.close(w0)
            os.dup2(r0, 0)              # make r0 stdin of the child
            if self.logfp:
                self.LOG("run persistent task %s\n" % cmd)
            os.execvp(cmd[0], cmd)
        else:
            os.close(w)
            os.close(r0)
            os.close(w0)
            return cmd,pid,r
        
    def xxmk_lnk(self, f, from_dir):
        real_f = os.path.realpath(f)
        real_from_dir = os.path.realpath(from_dir)
        common = os.path.commonprefix(real_f, real_from_dir)
        d,base = os.path.split(real_f)
        relative_path = base
        while not os.path.samefile(common, d):
            d,base = os.path.split(d)
            realative_path = os.path.join("..", realative_path)
        return ('<a href="%s">%s</a>' % (relative_path, f))

    def show_state(self):
        if self.logfp:
            self.LOG(("%d/%d waiting/total jobs, "
                      "%d/%d free/total men, "
                      "socket = %s, make = %s, gxpc = %s, gxpc_fd = %s\n"
                      % (len(self.shots_todo), len(self.works),
                         len(self.free_men), len(self.men),
                         self.so_name, self.make_pid,
                         self.gxpc_pid, self.gxpc_fd)))

    FAST_UPDATE_THRESHOLD = 10
    
    def periodic(self, finished):
        self.show_state()
        t0 = self.cur_time()
        if (finished or self.last_record_time is None
            or
            (t0 > self.next_record_time_1
             and self.n_state_changes > xmake_server.FAST_UPDATE_THRESHOLD)
            or
            t0 > self.next_record_time_2):
            self.rec.record_state(finished)
            t1 = self.cur_time()
            time_to_next_1 = max((t1 - t0) * 10.0,
                                 self.opts.update_interval_1)
            time_to_next_2 = max((t1 - t0) * 10.0,
                                 self.opts.update_interval_2)
            if self.last_record_time < 10.0:
                # heuristics to update more eagerly in the beginning
                time_to_next_1 = min(3.0, time_to_next_1)
                time_to_next_2 = min(3.0, time_to_next_2)
            self.last_record_time = t1
            self.next_record_time_1 = t1 + time_to_next_1
            self.next_record_time_2 = t1 + time_to_next_2
            self.n_state_changes = 0

    def run_make(self):
        """
        run GNU make. return pid
        """
        # set envinronment variable that affects all subsequent
        # invocations of make
        makefiles = os.environ.get("MAKEFILES")
        xmake_mk = os.path.join(os.environ["GXP_DIR"],
                                os.path.join("gxpbin", "xmake.mk"))
        if makefiles is None:
            os.environ["MAKEFILES"] = xmake_mk
        else:
            os.environ["MAKEFILES"] = "%s %s" % (xmake_mk, makefiles)
        os.environ["GXP_MAKELEVEL"] = "1"
        os.environ["GXP_MAKE_EXIT_STATUS_CONNECT_FAILED"] = ("%d" % self.opts.exit_status_connect_failed)
        os.environ["GXP_MAKE_EXIT_STATUS_SERVER_DEAD"] = ("%d" % self.opts.exit_status_server_dead)
        if self.opts.local_exec_cmd is not None:
            os.environ["GXP_MAKE_LOCAL_EXEC_CMD"] = self.opts.local_exec_cmd
        pid = os.fork()
        if pid == 0:
            self.close_fds()
            args = [ self.opts.make ] + self.make_args
            if self.logfp:
                self.LOG("run make %s\n" % args)
            os.execvp(args[0], args)
        else:
            return pid

    def sigchld(self, num, frame):
        """
        Handler of SIGCHLD. see below.
        """
        if self.logfp:
            self.LOG("sigchld handler %d\n" % self.child_wfd)
        try:
            x = os.write(self.child_wfd, "x")
            assert x == 1
            self.n_sigchild_written = self.n_sigchild_written + 1
        except OSError,e:
            if e.args[0] == errno.EBADF:
                if self.logfp:
                    self.LOG("sigchld failed to write\n")
            else:
                raise
        if self.logfp:
            self.LOG("sigchld handler returns\n")

    def mk_sigchld_handler(self):
        """
        register signal handler and notification pipe.
        """
        r,w = os.pipe()
        self.child_rfd = r
        self.child_wfd = w
        self.n_sigchild_written = 0
        self.n_sigchild_read = 0
        signal.signal(signal.SIGCHLD, self.sigchld)

    def handle_child_death(self):
        """
        called after a child terminates.
        when a child terminates, OS first calls the sigchld.
        it simply writes one byte to child_wfd.
        meanwhile, the main thread selects child_rfd, so
        it will know a child terminates, and handles it.
        
        """
        w = self.n_sigchild_written
        r = self.n_sigchild_read
        if self.logfp:
            self.LOG("handling child death (w=%d,r=%d)\n" % (w, r))
        x = w - r
        # I don't know why, but it really happens that
        # written < read.
        if x <= 0: x = 1

        x = 100
        try:
            a = os.read(self.child_rfd, x)
        except IOError,e:
            if e.args[0] == errno.EINTR:
                if self.logfp:
                    self.LOG("read interrupted\n")
                return
            else:
                raise
        if self.logfp:
            self.LOG("got %s from child_rfd\n" % a)
        self.n_sigchild_read = self.n_sigchild_read + len(a)
        pids = []
        while 1:
            try:
                pid,status = os.waitpid(-1, os.WNOHANG)
            except OSError,e:
                if e.args[0] == errno.ECHILD: break
                raise
            if pid == 0: break
            pids.append((pid, status))
        for pid,status in pids:
            if self.logfp:
                self.LOG("child (%d) terminated with %d\n" % (pid, status))
            if pid == self.make_pid:
                if self.logfp:
                    self.LOG("it is the child make\n")
                self.make_pid = None
                self.make_status = status
            elif pid == self.gxpc_pid:
                if self.logfp:
                    self.LOG("it is the initial process\n")
                self.gxpc_pid = None
                self.gxpc_status = status
            elif self.shots.has_key(pid):
                if self.logfp:
                    self.LOG("it is a shot running locally\n")
                shot = self.shots[pid]
                assert shot.id == pid, (shot.id, pid)
                self.handle_fin(shot, status)
            elif pid == self.pinger.ping_pid:
                if self.logfp:
                    self.LOG("it is a ping job\n")
                self.pinger.ping_pid = None
            else:
                if self.logfp:
                    self.LOG("it is another job\n")
            self.n_state_changes = self.n_state_changes + 1
        if self.logfp:
            self.LOG("%d children reaped\n" % len(pids))
                
    def close_socket(self):
        if self.so:
            if self.logfp:
                self.LOG("closing request socket %s\n" % self.so_name)
            self.so.close()
            self.so = None
            os.remove(self.so_name)
            self.so_name = None
        
    def kill_gxpc(self):
        if self.gxpc_pid is not None:
            if self.logfp:
                self.LOG(("killing initial process and children %s\n"
                          % self.gxpc_pid))
            os.kill(self.gxpc_pid, signal.SIGINT)

    def prepare_cleanup(self):
        if self.cleaning: return
        self.cleaning = 1
        self.close_socket()
        self.kill_gxpc()
        self.abandon_all_shots_todo()

    def abandon_all_shots_todo(self):
        cur_time = self.cur_time()
        status = self.status_time_limit
        shots = self.shots.values()
        if self.logfp:
            self.LOG(("exiting %d outstanding processes\n"
                      % len(shots)))
        for shot in shots:
            shot.finish(status, cur_time)
        self.shots = {}
        if self.logfp:
            self.LOG(("exiting %d waiting processes\n"
                      % len(self.shots_todo)))
        while len(self.shots_todo) > 0:
            shot = self.shots_todo.pop(0)
            shot.finish(status, cur_time)
        
    def determine_exit_status(self):
        s = self.make_status
        if s is None:
            return 1
        elif os.WIFEXITED(s):
            return os.WEXITSTATUS(s)
        elif os.WIFSIGNALED(s):
            pid = os.getpid()
            os.kill(pid, os.WTERMSIG(s))
            os.waitpid(pid, 0)
            assert(0)
        
    def server_main(self):
        """
        main loop
        """
        self.status_time_limit = os.system(("exit %d"
                                            % self.opts.exit_status_time_limit))
        self.status_worker_dead = os.system("exit %d"
                                            % self.opts.exit_status_worker_dead)
        
        self.mk_sigchld_handler() # register sig handler
        self.make_pid = self.run_make() # run GNU make
        self.works = []                 # list of works
        self.shots_todo = []            # shots to do
        self.shots = {}                 # shots in progress (pid/rid -> )
        self.matches = []
        self.men = {}                   # list of free men
        self.local_man = Man(local_man_name, len(self.men), 1, self.cur_time())
        self.men[local_man_name] = self.local_man
        self.free_men = []
        self.interrupted = 0
        self.hostname = socket.gethostname()
        self.periodic(0)
        while 1:
            try:
                if self.server_iterate() == 0: break
                self.periodic(0)
            except KeyboardInterrupt:
                self.interrupted = self.interrupted + 1
        self.periodic(1)
        return self.determine_exit_status()

    def server_iterate(self):
        # take some special action for time limit
        # (1) soft limit reached and no work in flight
        # (2) hard limit reached
        if self.interrupted == 0:
            int_at = self.opts.interrupt_at
            nd_after = self.opts.no_dispatch_after
            cur_time = self.cur_time()
            if int_at is not None and cur_time > int_at:
                self.interrupted = 1
                msg = ("hard limit %.3f reached. outstanding jobs will"
                       " be killed with SIGINT. waiting jobs will exit"
                       " with %d\n" % (int_at, self.opts.exit_status_time_limit))
                if self.logfp:
                    self.LOG(msg)
                Es("xmake: %s" % msg)
            elif nd_after is not None and \
                     cur_time > nd_after and len(self.shots) == 0:
                self.interrupted = 1
                msg = ("soft limit %.3f reached. wait for outstanding"
                       " jobs to finish. waiting jobs will exit with %d\n"
                       % (nd_after, self.opts.exit_status_time_limit))
                if self.logfp:
                    self.LOG(msg)
                Es("xmake: %s" % msg)

        if self.make_pid is None or self.interrupted > 0:
            if self.gxpc_pid is None and self.gxpc_fd is None:
                if self.make_pid is None:
                    return 0
                else:
                    if self.logfp:
                        self.LOG(("waiting for make %s to terminate\n"
                                  % self.make_pid))
            else:
                self.prepare_cleanup()
        # loop while make is still alive
        n_dispatched_jobs = self.dispatch()
        # wait until we receive something
        R = [ self.child_rfd ]
        if self.so: R.append(self.so)
        if self.gxpc_fd: R.append(self.gxpc_fd)
        if self.n_state_changes > xmake_server.FAST_UPDATE_THRESHOLD:
            nr = self.next_record_time_1
        else:
            nr = self.next_record_time_2
        int_at = self.opts.interrupt_at
        cur_time = self.cur_time()
        if int_at is not None and int_at < nr:
            timeout = int_at - cur_time
        else:
            timeout = nr - cur_time
        if timeout < 0.0: timeout = 0.0
        if n_dispatched_jobs == 0 and timeout < 1.0:
            timeout = 1.0
        if self.logfp:
            self.LOG("select(%d, timeout=%.2f)\n" % (len(R), timeout))
        try:
            RR = []
            RR,_,_ = select.select(R, [], [], timeout)
        except select.error,e:
            if e.args[0] == errno.EINTR:
                if self.logfp:
                    self.LOG("select interrupted\n")
            else:
                raise
        if self.so in RR: self.recv_works()
        if self.gxpc_fd in RR: self.recv_fins()
        if self.child_rfd in RR: self.handle_child_death()
        return 1

    def ensure_directory(self, dire):
        try:
            os.mkdir(dire)
        except OSError,e:
            if e.args[0] == errno.EEXIST:
                pass
            else:
                raise
        if os.path.isdir(dire): return 0
        Es("xmake: could not make a state directory %s\n" % dire)
        return -1

    def main(self):
        if self.parse_args(sys.argv) == -1:
            return 1
        if self.opts.help:
            Es(self.opts.usage())
            return 1
        if self.ensure_directory(self.opts.state_dir) == -1: return 1
        if self.open_LOG() == -1: return 1
        self.semaphores = self.mk_semaphores()
        if self.semaphores is None: return 1
        self.tid = "tid_make_%d_%d" % (os.getpid(), random.randint(0, 10000))
        self.gxpc_cmd,self.gxpc_pid,self.gxpc_fd = self.run_persistent_e(self.tid)
        self.gxpc_partial_msg = ""
        self.so,self.so_name = self.mk_server_socket()
        self.parallelism = [ (self.cur_time(), 0) ]
        self.conf = xmake_server_conf()
        self.conf.parse(os.path.expanduser(self.opts.conf))
        try:
            return self.server_main()
        finally:
            self.periodic(1)
            self.close_LOG()
            
if __name__ == "__main__":
    sys.exit(xmake_server().main())

#
# memo (staging)
#
# (1) add the following lines in gxpc_make.conf
#
# preprocess staging_in_cmd
# postprocess staging_out_cmd
#
# then, for each command executed by make, staging_in_cmd is
# executed before it, and staging_out_cmd after it, 
# by the same worker (thus on the same host) as the one
# executing the command itself. e.g.,
#
# preprocess echo hello
# postprocess echo bye
#
# will print hello and bye before and after each command.
#
# (2) if the staging_in_command or staging_out_cmd include %(cmd)s,
# it will be replaced by the command to be executed, with all quote
# characters (' and ") replaced by spaces for the reasons explained shortly.
# this will allow you to analyze the line and decide what to do based
# on the command line.
#
# preprocess ./your_stage_in_tool '%(cmd)s'
# postprocess ./your_stage_out_tool '%(cmd)s'
#
# will call ./your_stage_in_tool 'enju foo' for the command 'enju foo'
# executed by make. by looking at the command line in your_stage_in_tool,
# you may perhaps want to stage in foo somehow.
#
# note that it is not mandatory, but highly recommended to quote the %(cmd)s,
# to avoid problems associated with shell special characters. for example,
# if the command is 'enju foo > hello', what will be executed before this
# is './your_stage_in_tool enju foo > hello', which is probably not what
# you intended.
#
# there would still be a problem if the command includes ' chracter and
# substitute %(cmd)s for it. to avoid this problem, it currently replaces
# all ' and " with spaces.
#



